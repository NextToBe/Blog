#RESTFUL 接口设计

###REST设计初阶
要理解RESTful架构，最好的方法就是去理解 *Representational State Transfer* 这个词组，直译过来就是「**表现层状态转化**」，其实它省略了主语。「表现层」其实指的是「**资源**」的「表现层」，所以通俗来讲就是：资源在网络中以某种表现形式进行状态转移。分解开来：

* Resource：资源，即数据。比如 newsfeed，friends，order 等
* Representational：某种表现形式，比如用 JSON，XML，html，JPG等
* State Transfer：状态变化。通过 HTTP 动词实现。

然后再来理解一个具体的 RESTful 架构——面向资源的架构（Resource-Oriented Architecture，ROA）：

* 资源是由 URI 来指定。所谓「上网」，就是与互联网上一系列的「资源」互动，调用它的URI
* 对资源的操作包括获取、创建、修改和删除资源，这些操作正好对应HTTP协议提供的 GET、POST、PUT和 DELETE方 法。
* 通过操作资源的表现形式来操作资源。具体表现形式，应该在HTTP请求的头信息中用 Accept 和Content-Type 字段指定。
* 资源的表现形式则是 XML 或者 HTML，取决于读者是机器还是人，是消费web服务的客户软件还是web浏览器。当然也可以是任何其他的格式

应用于Web服务，符合 REST 设计风格的Web API称为 RESTful API。它从以下三个方面资源进行定义：

* 直观简短的资源地址：URI，比如：<http://example.com/resources/>，每一个URI代表一种**资源**；
* 传输的资源：Web服务接受与返回的互联网媒体类型，比如：JSON，XML，YAML等
* 对资源的操作：Web服务在该资源上所支持的一系列请求方法（比如：POST，GET，PUT 或 DELETE）。

###REST 设计进阶
####第一级：在架构中引入资源（Resource）的概念。
大多数WS-*服务和 POX 都只是使用一个 URI 作为一个服务端口，也只使用一个 HTTP 方法传输数据。这种做法相当于把 HTTP 这个应用层协议降级为传输层协议用，《REST 实战》也一再强调HTTP是一种应用协议而不是传输协议。再好一点就是使用多个 URI，然而不同的 URI 只是作为不同的调用入口，与此同时只使用同一个 HTTP 方法传输数据。最常见的错误就是在 URI 中包含动词，比如 URI <http://example.com/getDoc?docID=1>，其实「资源」表示一种实体，所以应该是名词，动词应该放在HTTP协议中。而与此同时URI也有可能破坏 HTTP GET 的安全性和幕等性，比如某个客户端在<http://example.com/updateDoc?id=1&name=air>上执行 GET（而不是 POST），就能创建一笔新的咖啡订单（一个资源），按理来说 GET请求是幂等的，不能改变服务的任何状态。

####第二级：每一个 URI 代表一种资源，支持 HTTP 动词。
此时使用多个 URI 的话，需要让不同的 URI 代表不同的资源（注意多个 URI 可能指向同一个Resource，而一个 URI 不能指向不同Resource。），同时使用多个 HTTP 方法操作这些资源，例如使用 POST/GET/PUT/DELET 分别进行 CRUD 操作。这时候 HTTP 头和有效载荷都包含业务逻辑，例如HTTP方法对应CRUD操作，HTTP状态码对应操作结果的状态。我们现在看到的大多数所谓 RESTful API做到的也就是这个级别。《REST实战》的译者也谈到：悟性差的人，理解到CRUD式Web服务就满足了（比如我）。而悟性好的人，可以彻底理解超文本驱动，甚至是与REST关系密切的语义网，最终达到 REST开发的最高境界。

####第三级：HATEOAS，使用超媒体（hypermedia）作为应用状态引擎
根据 Roy 的严格规定，超媒体（hypermedia）是 REST 的先决条件。任何其他东西不应该自我标榜为REST。要解释HATEOAS这个概念先要解释什么是超媒体：我们已经知道什么是多媒体（multimedia），以及什么是超文本（hypertext）。其中超文本特有的优势是拥有超链接（hyperlink）。如果我们把超链接引入到多媒体当中去，那就得到了超媒体，因此关键角色还是超链接。使用超媒体作为应用引擎状态，意思是应用引擎的状态变更由客户端访问不同的超媒体资源驱动。

比如下面这个例子：

```json
GET https://api.example.com/profile

{
  "name": "Air",
  "pictures": {
    "large": "https://somecdn.com/pictures/1200x1200.png",
    "medium": "https://somecdn.com/pictures/100x100.png",
    "small": "https://somecdn.com/pictures/10x10.png"
  }
}
```
由于在响应中包含了链接地址，因此使用该 API 的客户端就能够自由选择要下载怎样的信息。这些链接告知了客户端有哪些选择，并且它们的地址在哪里。因此在这里我们无需同时返回三个不同版本的用户档案图片，我们所做的只是告诉客户端有三种可用的图片尺寸可以选择，并且告诉客户端能够在哪里找到这些图片。这样一来，客户端就能够根据不同的场景，做出符合自身需要的选择。而且，如果客户端只需要一种格式的图片，那就无需下载全部三种版本的图片了。这样一来可谓一箭三雕：既减少了网络负载，又增进了客户端的灵活性，更增进了API的可探索性。


超媒体的核心概念就是***链接***，而这些相互链接的资源实际上描述了一个协议，即引导我们达成某个目标的一系列步骤，例如订购一杯咖啡所需要的点单、付款、取咖啡等等。这就是超媒体的本质：经由资源之间的链接，我们改变整个应用的状态，即超媒体转换了分布式应用的状态。需要注意的是，服务器和消费者两者间交换的是资源状态的表述，而不是应用的状态，被转移的表述中包括了反应应用状态的链接。