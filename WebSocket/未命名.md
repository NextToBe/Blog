# Spring WebSocket 实战 — 实现点对点通信



***本文将简单介绍通过使用 Spring 框架的 websocket 来实现点对点的安全通信***

 



##maven 依赖

本次的 *maven* 依赖主要是:

* Spring Security
* Spring Websocket
* Spring Messaging
* Spring Security Messaging



## Spring Websocket 配置

首先要说明的是本次实验使用的并不是纯正的 ***websocket*** 协议，而是基于 ***websocket*** 协议的 ***STOMP*** 协议，所以在使用上会有一定的偏差。之所以要使用



```java
@Configuration
@EnableWebSocketMessageBroker
public class OaWebSocketSecurityConfiguration extends AbstractSecurityWebSocketMessageBrokerConfigurer {

  @Override
  protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
    messages.nullDestMatcher().authenticated().simpSubscribeDestMatchers("/channel/**").permitAll()
        .simpSubscribeDestMatchers("/user/**").authenticated();
  }

  @Override
  protected boolean sameOriginDisabled() {
    // disable csrf
    return true;
  }

  @Override
  public void registerStompEndpoints(StompEndpointRegistry registry) {
    registry.addEndpoint("/ws").setAllowedOrigins("*").withSockJS();
    registry.addEndpoint("/ws").setAllowedOrigins("*");
  }

  @Override
  public void configureMessageBroker(MessageBrokerRegistry registry) {
    registry.setApplicationDestinationPrefixes("/app");
    registry.enableSimpleBroker("/channel", "/user");
    registry.setUserDestinationPrefix("/user");
  }

}

```

上面的注解 ***EnableWebSocketMessageBroker***  不仅配置了 WebSocket，还配置了基于代理的 STOMP 消息， 它复写了 ***registerStompEndpoints()*** 方法：添加一个服务端点，来接收客户端的连接。将 ***/ws*** 路径注册为 STOMP 端点。这个路径与之前发送和接收消息的目的路径有所不同， 这是一个端点，客户端在订阅或发布消息到目的地址前，要连接该端点，即用户发送请求 ：***url  = /127.0.0.1:8080/ws*** 与 *STOMP Server* 进行连接，之后再转发到订阅 *url*  。同时，它还复写了 ***configureMessageBroker()*** 方法：配置了一个 简单的消息代理，通俗一点讲就是设置消息连接请求的各种规范信息。





## 监听连接与订阅事件

```java
@Service
@Slf4j
public class MessageWebSocketService {

  private static final String MESSAGE_DESTINATION = "/message";

  private static final String SESSION_ID = "simpSessionId";

  private static final String USER = "simpUser";

  private static final String DESTINATION = "simpDestination";

  private ConcurrentHashMap<String, String> userSessionMap = new ConcurrentHashMap<>();

  @Autowired
  EmployeeService employeeService;

  @Autowired
  IMessageService messageService;

//  @Autowired
  SimpMessagingTemplate template;


  @EventListener
  public void handleSessionConnneted(SessionConnectedEvent event) {
    userSessionMap.put(getUserLdapAccount(event), getSessionId(event));
  }

  @EventListener
  public void handleSessionSubscribe(SessionSubscribeEvent event) {
    String destination = getDestination(event);
    String[] segs = destination.split("/");
    if (!segs[0].equals("user")) {
      return;
    }

    String user = segs[2];
    String ldapAccount = getUserLdapAccount(event);
    if (!ldapAccount.equals(user)) {
      userSessionMap.remove(ldapAccount);
      throw new YqgException(OaErrorCode.NOT_AUTHORIZED, "您没有权限监听他人的端口");
    }

    EmployeeVO employeeVO = employeeService.fetchEmployeeByLdapAccount(getUserLdapAccount(event));
    if (employeeVO != null) {
      List<MessageVO> messageVOS = messageService.fetchUnsendMessages(employeeVO.id);
      sendMessageToUser(employeeVO.ldapAccount, messageVOS);
    }
  }


  @EventListener
  public void handleSessionDisconnet(SessionDisconnectEvent event) {
    if (!userSessionMap.containsKey(getUserLdapAccount(event))) {
      return;
    }

    userSessionMap.remove(getUserLdapAccount(event));
  }

  private String getSessionId(AbstractSubProtocolEvent event) {
    MessageHeaders headers = event.getMessage().getHeaders();
    return (String) headers.get(SESSION_ID);
  }

  private String getUserLdapAccount(AbstractSubProtocolEvent event) {
    MessageHeaders headers = event.getMessage().getHeaders();
    UsernamePasswordAuthenticationToken token = (UsernamePasswordAuthenticationToken) headers.get(USER);
    ldapUserDetailsImpl user = (LdapUserDetailsImpl) token.getPrincipal();
    return user.getUsername();
  }

  private String getDestination(AbstractSubProtocolEvent event) {
    MessageHeaders headers = event.getMessage().getHeaders();
    return (String) headers.get(DESTINATION);
  }


  public boolean sendMessageToUser(String userLdapAccount, List<MessageVO> messageVOS) {
    if (!userSessionMap.containsKey(userLdapAccount)) {
      return false;
    }

    try {
//      template.convertAndSendToUser(userLdapAccount, MESSAGE_DESTINATION, messageVOS);
      return messageService.markAsSent(messageVOS.stream().map(MessageVO::getId).collect(Collectors.toList()));
    } catch (MessagingException ex) {
      log.error("sending to {} error.", userLdapAccount, ex);
      return false;
    }

  }
```





## 前端部分代码



```javascript
function connect(event) {
    username = document.querySelector('#name').value.trim();

    if (username) {

        usernamePage.classList.add('hidden');
        chatPage.classList.remove('hidden');

        var socket = new SockJS('/ws');
        stompClient = Stomp.over(socket);

        stompClient.connect({}, onConnected, onError);
    }
    event.preventDefault();
}


function onConnected() {
    // Subscribe to the Public Channel
    stompClient.subscribe('/channel/chatRoom', onMessageReceived);

    stompClient.subscribe('/user/{yourUserName}/message', onMessageReceived);

    stompClient.subscribe('/user/queue/error', onErrorReceived);

    connectingElement.classList.add('hidden');
}


function onError(error) {
    connectingElement.textContent = 'Could not connect to WebSocket server. Please refresh this page to try again!';
    connectingElement.style.color = 'red';
}


function sendMessage(event) {
    var messageContent = messageInput.value.trim();

    if (messageContent && stompClient) {
        var chatMessage = {
            sender: username,
            content: messageInput.value
        };

        stompClient.send("/app/chat/sendMessage", {}, JSON.stringify(chatMessage));
        messageInput.value = '';
    }
    event.preventDefault();
}
```





## 结语