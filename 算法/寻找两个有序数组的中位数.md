# 寻找两个有序数组的中位数

本题是 [LeetCode#4](#https://leetcode.com/problems/median-of-two-sorted-arrays/description/) 的题目，原题描述如下：

```
There are two sorted arrays nums1 and nums2 of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
```

第一眼看上去这个题目的解法是可以将两个数组进行归并排序，之后直接返回新的数组的中位数即可，然而这样一来，时间复杂度为 O(m + n), 空间复杂度也为 O(m + n)，而题中要求时间复杂度为 O(log (m + n)), 于是这种解法作罢。

而 O(log(n)) 很容易让人想到二分查找，本文将**基于原高票答案进行解析以及记录**。

---

首先，我们看一下 **中位数** 的定义：

	对于一组有限个数的数据来说，它们的中位数是这样的一种数：这群数据里的一半的数据比它大，而另外一半数据比它小。 计算有限个数的数据的中位数的方法是：把所有的同类数据按照大小的顺序排列。 如果数据的个数是奇数，则中间那个数据就是这群数据的中位数；如果数据的个数是偶数，则中间那2个数据的算术平均值就是这群数据的中位数。 -- 维基百科
显然，在奇数个数的数组 **arr1 = [1, 3, 5]** 中，中位数是 *3*， 而在偶数个数的数组中 **arr2 = [1, 3, 5, 7]** 中， 中位数为 (3 + 5) / 2 = 4。中位数将数组划分为两部分，在 arr2 中，显然划分为 *[1, 3 / 5, 7]*， 而在 arr1 中，则划分为 *[1, (3 / 3), 5]*。

在上述的例子🌰中，我们使用了分隔符 **/** 来分割数组，为了方便表述，使用 ***L*** 来代表被分隔符分割的左边的数字，而 ***R*** 代表右边的。 比如在 arr1中， *L = 3* ， *R = 3*， 在 arr2 中，*L = 3*， *R = 5*。 故在一个长度为 **N** 的升序数组 **A** 中， 它的长度与 L 和 R 的关系如下表：

|  N   | L 的下标 / R 的下标 |
| :--: | :-----------: |
|  1   |     0 / 0     |
|  2   |     0 / 1     |
|  3   |     1 / 1     |
|  4   |     1 / 2     |
|  5   |     2 / 2     |

由此我们可以得出结论： ***L = (N-1)/2， R = N / 2***， 

而中位数可以表示为：***(L + R) / 2 = (A[(N - 1) / 2] + A[N / 2]) / 2***



----



在进入重点之前，我们先要明确一个 概念 ：叫做 “’中位数分割点”，在上面的例子中，arr1中的分割点是 3， arr2中的分割点是在 3 和 5 之间，那么一个长度为 N 的数组有多少个分割点？ 答案是明确的： **2N + 1**



我们不妨来做一个高中的最简单的排列组合问题：

```
一个汉堡🍔店门口排起了长长的队伍，这时候来了一个蛮不讲理的顾客：他要插队。请问他有多少种插队的方式？
```

既然要插队，那么可以排在最前，也可以排在最后。

```
[1, 2, 3, 4, 5] -> [#, 1, #, 2, #, 3, #, 4, #, 5, #]

可以看出原先5人的队伍，他会有6个位置选择，故而原题答案为 N + 1
```



而本题与插队问题不太相同，还记得我们的奇数数组如何划分的吗？ arr1被划分为  *[1, (3 / 3), 5]*。故而为了寻找中位数，原数组的数字也可以被分割为前后相等的两部分。

```,
[1, 2, 3, 4, 5] -> [#, 1, #, 2, #, 3, #, 4, #, 5,  #]
分割点的下标：		   1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11

可以看出，原先长度为 5 的数组，将会有 5 * 2 + 1 个分割点
```



再说说中位数，在单个**升序**数组的情况下，根据定义我们是要找到中间位置的数字，那么也就是说：**中间位置** 的数字也就是 **中间大小** 的数字，也就是说 ***中位数左边的数字一定 <= 中位数右边的数字***

再说回题目：两个升序数组，假设 *A1 = [1, 1, 1, 1]*， 长度为 *m = 4*，*A2 = [1, 2, 3, 4, 5]*， 长度为 *n = 5*。所以我们有以下结论：

 *  两个数组加起来有 ***2m + 2n + 2 = 20*** 个分割点，其中，两个事实分割点(真正分割的地方)占用两个名额，所以，两个事实分割点左右两边各有分割点 ***m + n = 9*** 个

 *  基于上一条，假设 A1的分割点为 ***C1 = k***，则 A2 的分割点 ***C2 = m + n - k*** ，在这两个数组中，分割如下：

    ```
    [#, 1, /, 1, #, 1, #, 1, #]   
    	   ↑                ↓   箭头所指的就是事实分割点，即C1, C2
    [#, 1, #, 2, #, 3, #, (4/4), #, 5, #]    
    ```

    可见，**C1 = 2**，而 ***C2 = m + n - 2* = 7**

    ​

延续我们对 ***L、 R*** 的定义，则有:

 *   ***L1 = A1[(C1 - 1) / 2];  R1 = A1[C1 / 2]***

 *   ***L2 = A2[(C2 - 1) / 2];  R2 = A2[C2 / 2]***

     ​

对于上述两个数组，有 ***L1 = A1[(2 - 1) / 2] = 1, R1 = A1[2 / 2] = 1;  L2 = A2[(7 - 1) / 2] = 4, R2 = A2[7 / 2] = 4***。



那么问题来了，我们到底如何分割 A1和 A2呢？前面我们说了，中位数既是中间位数的数字，也是中间大小的数字。所以我们需要保证 *L1* 和 *L2* 是左边部分的最大数字，而 *R1* 和 *R2* 是右边部分的最小数字即可。也就是：

​	***L1 <= R1 && L1 <= R2 && L2 <= R1 && L2 <= R2***



而在原数组中，数组是升序的，故只需要保证 ***L1 <= R2 && L2 <= R1*** 即可。

当查找进行到了最后时刻， 我们就可以根据 L1，L2，R1，R2 计算出中位数。



​	***res =  (max(L1, L2) + min(R1, R2)) / 2***





最后，我们基于这个条件使用 ***二分查找*** 写下代码：



 ```java
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int length1 = nums1.length, length2 = nums2.length;
        if (length1 > length2) {
          	// 保证 nums1 长度小于 nums2
            return findMedianSortedArrays(nums2, nums1);
        }
        
        // 使用分割点来查找, 故最大分隔点的下标为 2 * n + 1 - 1 = 2n
        int low = 0, high = nums1.length * 2;
        while (low <= high) {
            // mid为当前分割点; 防止溢出
            int mid1 = low + (high - low) / 2;
            // C2 = m + n - C1
            int mid2 = length1 + length2 - mid1;
            
            // 根据推论计算 L1，L2，R1 和 R2
            double l1 = (mid1 == 0) ? Integer.MIN_VALUE : nums1[(mid1 - 1) / 2];
            double l2 = (mid2 == 0) ? Integer.MIN_VALUE : nums2[(mid2 - 1) / 2];
            double r1 = (mid1 == length1 * 2) ? Integer.MAX_VALUE : nums1[mid1 / 2];
            double r2 = (mid2 == length2 * 2) ? Integer.MAX_VALUE : nums2[mid2 / 2];
            
          	// 需要保证 L1 <= R2 && L2 <= R1 
            if (l1 > r2) {
                high = mid1 - 1;
            } else if (l2 > r1) {
                low = mid1 + 1;
            } else {
                // 此时，已经找到正确的分割点，根据推论直接计算中位数
                return (Math.max(l1, l2) + Math.min(r1, r2)) / 2;
            }
        }
        
        return -1;
    }
 ```



由于只在较小的数组中进行了二分查找，故时间复杂度为 **O(log(2 * min(m, n))) <= O(log(m + n))**